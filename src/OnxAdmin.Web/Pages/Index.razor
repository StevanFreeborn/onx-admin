@page "/"
@implements IAsyncDisposable
@inject IJSRuntime JS
@inject IAnthropicService AnthropicService

<PageTitle>OnxAdmin</PageTitle>

<div class="container">
  <div class="messages-container">
    @foreach (var message in _messages)
    {
      @foreach (var content in message.Content)
      {
        if (content is TextContent textContent)
        {
          <div class="message message-@(message.Role.ToString().ToLower())">
            <div class="message-wrapper">
              @((MarkupString)Markdown.ToHtml(textContent.Text, _pipeline))
            </div>
          </div>
        }
        if (content is ToolUseContent toolUseContent)
        {
          <div class="message message-@(message.Role.ToString().ToLower())">
            <div class="tool-use">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                <path
                  d="M352 320c88.4 0 160-71.6 160-160c0-15.3-2.2-30.1-6.2-44.2c-3.1-10.8-16.4-13.2-24.3-5.3l-76.8 76.8c-3 3-7.1 4.7-11.3 4.7H336c-8.8 0-16-7.2-16-16V118.6c0-4.2 1.7-8.3 4.7-11.3l76.8-76.8c7.9-7.9 5.4-21.2-5.3-24.3C382.1 2.2 367.3 0 352 0C263.6 0 192 71.6 192 160c0 19.1 3.4 37.5 9.5 54.5L19.9 396.1C7.2 408.8 0 426.1 0 444.1C0 481.6 30.4 512 67.9 512c18 0 35.3-7.2 48-19.9L297.5 310.5c17 6.2 35.4 9.5 54.5 9.5zM80 408a24 24 0 1 1 0 48 24 24 0 1 1 0-48z" 
                />
              </svg>
              <p>@toolUseContent.Name</p>
            </div>
          </div>
        }
        if (content is ToolResultContent toolResultContent)
        {
          <div class="message message-assistant">
            <div class="tool-result @(toolResultContent.IsError.GetValueOrDefault() ? "error" : string.Empty)">
              @((MarkupString)Markdown.ToHtml(toolResultContent.Content, _pipeline))
            </div>
          </div>
        }
      }
    }
    @if (_isRunning)
    {
      <div class="message message-assistant">
        <div class="typing">
          <span></span>
          <span></span>
          <span></span>
        </div>
      </div>
    }
  </div>
  <div class="input-container">
    <div class="attachment-wrapper">
      @foreach (var file in _files)
      {
        <div class="attachment">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" fill="currentColor">
            <path d="M0 64C0 28.7 28.7 0 64 0H224V128c0 17.7 14.3 32 32 32H384V448c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V64zm384 64H256V0L384 128z"/>
          </svg>
          <p title="@file.Name">@file.Name</p>
          <button type="button" @onclick="@(() => _files.Remove(file))">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
              <path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z"/>
            </svg>
            <span class="sr-only">Remove Attachment</span>
          </button>
        </div>
      }
    </div>
    <div class="prompt-wrapper">
      <label for="fileInput" class="sr-only">File Input</label>
      <InputFile multiple OnChange="LoadFiles" style="display: none;" id="fileInput" name="fileInput" />
      <button class="attach-file-button" type="button" @onclick="OpenFileInput">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" fill="currentColor">
          <path d="M364.2 83.8c-24.4-24.4-64-24.4-88.4 0l-184 184c-42.1 42.1-42.1 110.3 0 152.4s110.3 42.1 152.4 0l152-152c10.9-10.9 28.7-10.9 39.6 0s10.9 28.7 0 39.6l-152 152c-64 64-167.6 64-231.6 0s-64-167.6 0-231.6l184-184c46.3-46.3 121.3-46.3 167.6 0s46.3 121.3 0 167.6l-176 176c-28.6 28.6-75 28.6-103.6 0s-28.6-75 0-103.6l144-144c10.9-10.9 28.7-10.9 39.6 0s10.9 28.7 0 39.6l-144 144c-6.7 6.7-6.7 17.7 0 24.4s17.7 6.7 24.4 0l176-176c24.4-24.4 24.4-64 0-88.4z"/>
        </svg>
        <span class="sr-only">Attach File</span>
      </button>
      <label for="prompt" class="sr-only">Prompt</label>
      <textarea 
        name="prompt" 
        id="prompt"
        placeholder="Message OnxAdmin" 
        @oninput="HandlePromptInput"
        @onfocus="HandlePromptFocus" 
        @onblur="HandlePromptBlur" 
        @onkeydown="HandlePromptKeydown" 
        rows="1" 
        dir="auto"
        value="@_prompt"
        disabled="@_isRunning"
      ></textarea>
      <button 
        type="button" 
        class="send-button" 
        @onclick="HandleSendButtonClick"
        disabled="@_isRunning"
      >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
          <path
            d="M498.1 5.6c10.1 7 15.4 19.1 13.5 31.2l-64 416c-1.5 9.7-7.4 18.2-16 23s-18.9 5.4-28 1.6L284 427.7l-68.5 74.1c-8.9 9.7-22.9 12.9-35.2 8.1S160 493.2 160 480V396.4c0-4 1.5-7.8 4.2-10.7L331.8 202.8c5.8-6.3 5.6-16-.4-22s-15.7-6.4-22-.7L106 360.8 17.7 316.6C7.1 311.3 .3 300.7 0 288.9s5.9-22.8 16.1-28.7l448-256c10.7-6.1 23.9-5.5 34 1.4z" 
          />
        </svg>
        <span class="sr-only">Send</span>
      </button>
    </div>
  </div>
</div>

@code
{
  private string _prompt { get; set; } = string.Empty;
  private string _assistantResponse { get; set; } = string.Empty;
  private bool _isRunning = false;
  private readonly List<Message> _messages = new List<Message>();
  private readonly List<IBrowserFile> _files = new List<IBrowserFile>();
  private IJSObjectReference? Module;
  private readonly MarkdownPipeline _pipeline = new MarkdownPipelineBuilder()
    .UseAdvancedExtensions()
    .UseAutoLinks(new() { OpenInNewWindow = true, UseHttpsForWWWLinks = true })
    .UseEmojiAndSmiley()
    .UseSoftlineBreakAsHardlineBreak()
    .Build();

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      Module = await JS.InvokeAsync<IJSObjectReference>("import", "./Pages/Index.razor.js");
      await Module.InvokeVoidAsync("initialize");
    }
  }

  async ValueTask IAsyncDisposable.DisposeAsync()
  {
    try
    {
      if (Module is not null)
      {
        await Module.DisposeAsync();
      }
    }
    catch (Exception ex) when (ex is JSDisconnectedException)
    {
      // The JS runtime is disconnected, no need to dispose
    }
  }

  private async Task OpenFileInput()
  {
    if (Module is not null)
    {
      await Module.InvokeVoidAsync("openFileInput");
    }
  }

  private async Task LoadFiles(InputFileChangeEventArgs e)
  {
    var files = e.GetMultipleFiles();

    foreach (var file in files)
    {
      _files.Add(file);
    }
  }

  private async Task HandlePromptFocus()
  {
    if (Module is not null)
    {
      await Module.InvokeVoidAsync("focusPrompt");
    }
  }

  private async Task HandlePromptBlur()
  {
    if (Module is not null)
    {
      await Module.InvokeVoidAsync("blurPrompt");
    }
  }

  private async Task HandlePromptInput(ChangeEventArgs e)
  {
    _prompt = e?.Value?.ToString() ?? string.Empty;

    if (Module is not null)
    {
      await Module.InvokeVoidAsync("resizePrompt");
    }
  }

  private async Task HandlePromptKeydown(KeyboardEventArgs e)
  {
    if (e.Key == "Enter" && e.CtrlKey)
    {
      await HandleSendButtonClick();
    }
  }

  private async Task AddMessage(Message msg)
  {
    if (msg.Role is RoleType.User)
    {
      _prompt = string.Empty;

      if (Module is not null)
      {
        await Module.InvokeVoidAsync("resetPrompt");
      }
    }

    _messages.Add(msg);
    StateHasChanged();

    if (Module is not null)
    {
      await Module.InvokeVoidAsync("scrollToBottom");
    }
  }

  private void UpdateRunningState(bool isRunning)
  {
    _isRunning = isRunning;
    StateHasChanged();
  }

  private async Task HandleSendButtonClick()
  {
    if (string.IsNullOrWhiteSpace(_prompt))
    {
      return;
    }

    UpdateRunningState(true);

    await AddMessage(new(RoleType.User, _prompt));

    MessageResponse? response = null;

    do
    {
      if (response is not null && response.ToolCalls.Count > 0)
      {
        foreach (var toolCall in response.ToolCalls)
        {
          try
          {
            var toolResult = await toolCall.InvokeAsync<string>();
            await AddMessage(new Message(toolCall, toolResult));
          }
          catch (Exception ex) when (ex is ToolException)
          {
            var toolResult = new ToolResultContent()
            {
              ToolUseId = toolCall.Id,
              Content = ex.Message,
              IsError = true
            };

            await AddMessage(new Message() { Role = RoleType.User, Content = [toolResult] });
          }
        }

        response = await AnthropicService.GenerateResponseAsync(_messages);
        await AddMessage(response.Message);
      }
      else
      {
        response = await AnthropicService.GenerateResponseAsync(_messages);
        await AddMessage(response.Message);
      }
    } while (response is not null && response.ToolCalls.Count > 0);

    UpdateRunningState(false);
  }
}